import os, sys
import utils
import pathlib
from scipy import ndimage
import cv2 as cv
from shapely import geometry as geo
from shapely.ops import unary_union
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.artist import Artist
from matplotlib.offsetbox import AnchoredText

from shapely.ops import polygonize
import math
from matplotlib.patches import Rectangle
import pandas as pd
import glob


def main():
    dir = os.getcwd()
    task = "Suturing"
    # try:
    #     task = sys.argv[1]
    # except:
    #     print("Error: no task provided", "Usage: python deeplab_nokin_context_v3.py <task>", "Default Task" + task)

    I = Iterator(task)
    I.GetGrasperDist(SAVE=False)

    V = VideoInterface(task)
    V.makevideos()
    quit();


class Iterator:

    def __init__(self, task):
        self.CWD = os.path.dirname(os.path.realpath(__file__))
        self.task = task
        self.plotImagesDir = os.path.join(self.CWD, task, "grasper_plot_images")
        self.plotNextToImagesDir = os.path.join(self.CWD, task, "grasper_plot_sidebyside")
        self.imagesDir = os.path.join(self.CWD, task, "images")
        self.cogitoDir = os.path.join(self.CWD, task, "annotations")
        self.cogitoOutputDir = os.path.join(self.CWD, task, "cogito_labeled_images")
        self.context_output = os.path.join(self.CWD, task, "vis_context_labels_v5")
        self.deeplabOutputDir = os.path.join(self.CWD, task, "deeplab_labeled_images")
        self.ctxConsensusDir = os.path.join(self.CWD, task, "ctx_consensus")
        self.ctxSurgeonDir = os.path.join(self.CWD, task, "ctx_surgeon")
        self.ctxPredDir = os.path.join(self.CWD, task, "ctx_output")
        self.tissueDir = os.path.join(self.CWD, task,
                                      "tissue_keypoints")  # contains VIA labels for the points on the canvas (Suturing)
        self.grasperJawDir = os.path.join(self.CWD, task,
                                          "grasper_jaw_keypoints")  # contains VIA labels for the grasper jaw points
        self.contourDir = os.path.join(self.CWD, task,
                                       "contour_points")  # All of the contour points generated by contours.py

        self.OS = "windows"

    def plotGrasperDist(self):
        # get grasper contour data
        # (aka from the output of contours.py)
        DeeplabVIAPoints, DeeplabVIAFrames, DeeplabVIARings = self.getContourData()

        # dictionary {frame_number : centroid point}
        gt_Centroid_L = {}
        gt_Centroid_R = {}
        pred_Centroid_L = {}
        pred_Centroid_R = {}
        gt_dist = {}
        pred_dist = {}

        # need to generate for all trials and all tasks
        # but for now focus on Suturing_S02_T01
        FilenamesInTask = [
            "Suturing_S02_T01"]  # self.getFilenamesinTask()  # These are all the trial we'll generate context labels for. We get this list from the images folder
        print("Trials:", "Suturing_S02_T01")  # FilenamesInTask)

        for Trial in FilenamesInTask:
            TrialRoot = os.path.join(self.imagesDir, Trial)
            ctxFName = os.path.join(self.ctxConsensusDir, Trial + ".txt")
            ctxPredFName = os.path.join(self.context_output, Trial + ".txt")
            frameNum = 0
            for root, dirs, files in os.walk(TrialRoot):
                files.sort()
                for file in files:
                    if "frame" not in file:
                        continue
                    frameNum += 1
                    imageRoot = root
                    frameNumber = int(file.replace(".png", "").split("_")[1])
                    trialFname = os.path.basename(root)
                    imageFName = os.path.join(imageRoot, file)
                    cogitoRoot = root.replace("images", "annotations")
                    cogitoFName = os.path.join(cogitoRoot, utils.imageToJSON(file))
                    outputRoot = os.path.join(self.deeplabOutputDir, trialFname)
                    # outputFName = os.path.join(self.deeplabOutputDir, trialFname, file)

                    gplotRoot = os.path.join(self.plotImagesDir, trialFname)
                    plot_file = 'plot_' + file
                    gplotFName = os.path.join(self.plotImagesDir, trialFname, plot_file)
                    # print("GPLOTFNAME:", gplotFName)

                    annotationRoot = root.replace("images", "annotations")
                    annotationFile = os.path.join(annotationRoot, utils.imageToJSON(file))

                    # All _dl_points contains the contours that are applicable for this Task and Trial combo
                    All_dl_points = DeeplabVIAPoints[trialFname]  # ["class"]["frame"] = list of points

                    # Getting particular contours (array of points)
                    try:
                        LgrasperPoints = All_dl_points["dl_grasper_L"][str(frameNumber)]
                    except Exception as e:
                        print(e, "in LgrasperPoints")
                        LgrasperPoints = {}

                    try:
                        RgrasperPoints = All_dl_points["dl_grasper_R"][str(frameNumber)]
                    except Exception as e:
                        print(e, "in RgrasperPoints")
                        RgrasperPoints = {}

                    CtxI = utils.ContextInterface2(ctxFName)
                    J = utils.JSONInterface(annotationFile)

                    # gtPolygons are Ground Truth contour points for the cogito labels
                    gtPolygons = J.getPolygonsDict();  # graspers only in KT, (don't need needle mask)
                    # print(type(gtPolygons)) # dict
                    # print(gtPolygons) # tool : points

                    # gtKeypoints are Ground Truth points from cogito labels
                    gtKeypoints = J.getKeyPointsDict();  # not needed, only for GetCommonShapes function
                    cn, polylineSeries = J.getPolyLines();  # not needed
                    SingleThreadX = []
                    SingleThreadY = []
                    for i in range(len(polylineSeries)):
                        l = len(polylineSeries)
                        for j in range(0, len(polylineSeries[i]), 2):
                            SingleThreadX.append(polylineSeries[i][j])
                            SingleThreadY.append(polylineSeries[i][j + 1])
                    SingleThreadPoints = [(SingleThreadX[i], SingleThreadY[i]) for i in range(len(SingleThreadX))]

                    if (not os.path.isdir(outputRoot)):
                        path = pathlib.Path(outputRoot)
                        path.mkdir(parents=True, exist_ok=True)

                    # pred has all of the polygons from Zoey's masks
                    # gt has all of the polygons from cogito
                    pred, gt = self.GetCommonShapes(gtPolygons, gtKeypoints, SingleThreadPoints, polylineSeries,
                                                    LgrasperPoints, RgrasperPoints)

                    pd, gd = self.GetGrasperDist(pred, gt)



                    # multipolygons in left and right graspers
                    gt_mpoly_l = gt[0]
                    gt_mpoly_r = gt[1]

                    pred_mpoly_l = pred[0]
                    pred_mpoly_r = pred[1]

                    # print("PRED_MPOLY_L:", pred_mpoly_l)
                    # print(type(pred_mpoly_l))

                    # find grasper center
                    for polygon in gt_mpoly_l:
                        gt_l_center = polygon.centroid
                        gt_Centroid_L[frameNumber] = gt_l_center
                        print("gt_Centroid_L:", gt_l_center)

                    for polygon in pred_mpoly_l:
                        pred_l_center = polygon.centroid
                        pred_Centroid_L[frameNumber] = pred_l_center
                        print("pred_Centroid_L:", pred_l_center)

                    for polygon in gt_mpoly_r:
                        gt_r_center = polygon.centroid
                        gt_Centroid_R[frameNumber] = gt_r_center
                        print("gt_Centroid_R:", gt_r_center)

                    for polygon in pred_mpoly_r:
                        pred_r_center = polygon.centroid
                        pred_Centroid_R[frameNumber] = pred_r_center
                        print("pred_Centroid_R:", pred_r_center)

                    # finding distance between graspers of gt and pred
                    pred_d = pred_l_center.distance(pred_r_center)
                    pred_dist[frameNumber] = pred_d
                    print("PRED_DIST", pred_d)

                    gt_d = gt_l_center.distance(gt_r_center)
                    gt_dist[frameNumber] = gt_d
                    print("GT_DIST", gt_d)

            print("proc", os.path.basename(TrialRoot), "count:", frameNum)
        print(gt_Centroid_L)
        print(pred_Centroid_L)
        print(gt_Centroid_R)
        print(pred_Centroid_R)
        print(pred_dist)
        print(gt_dist)
        print("done processing")
        return gt_Centroid_L, gt_Centroid_R, pred_Centroid_L, pred_Centroid_R, gt_dist, pred_dist

        ### BREAK ###

        # plot location of grasper center on 2D plot
        # over time
        # plotting distance between vs. time

    def plotGrasperDist(self):
        gt_dist = {}
        pred_dist = {}
        gt_Centroid_L, gt_Centroid_R, pred_Centroid_L, pred_Centroid_R, gt_dist, pred_dist = self.GetGrasperDist()

        # for gt
        # create dataframe
        gt_dataframe = pd.DataFrame({'frame_number': gt_dist.keys(),
                                     'distance': gt_dist.values()})

        # for pred
        # create dataframe
        pred_dataframe = pd.DataFrame({'frame_number': pred_dist.keys(),
                                       'distance': pred_dist.values()})

        # for gt?

        # for pred
        for n in pred_dist.keys():  # for each frame number
            # plot entire graph
            # Plotting the time series of given dataframe
            plt.plot(pred_dataframe.frame_number, pred_dataframe.distance, color='blue')

            # Giving title to the chart using plt.title
            plt.title('Distance Between Graspers by Frames')

            # Providing x and y label to the chart
            plt.xlabel('Frame')
            plt.ylabel('Distance Between Graspers')

            # draw vertical line at each frame number
            # save each graph
            # only one line may be specified; full height
            line = plt.axvline(x=n, color='red', label='axvline - full height')
            # frame number test
            f_text = plt.text(5050, 530, "Frame " + str(n))

            # change savefig default directory output
            # to: in task (Suturing), folder grasper_plot_images, in appropriate Trial folder
            plot_filename = 'plot_frame_' + str(n).zfill(4) + '.png'  # add leading zeros
            plot_file_path = os.path.join(gplotRoot, plot_filename)
            # print("PLOT_FILE_PATH: ", plot_file_path)

            # plt.savefig(plot_file_path)
            line.remove()
            f_text.remove()

            # here: have saved plots for each frame

    def GetGrasperDist(self, pred, gt):
        # multipolygons in left and right graspers
        gt_mpoly_l = gt[0]
        gt_mpoly_r = gt[1]

        pred_mpoly_l = pred[0]
        pred_mpoly_r = pred[1]

        # print("PRED_MPOLY_L:", pred_mpoly_l)
        # print(type(pred_mpoly_l))

        # find grasper center
        for polygon in gt_mpoly_l:
            gt_l_center = polygon.centroid
            #gt_Centroid_L[frameNumber] = gt_l_center
            print("gt_Centroid_L:", gt_l_center)

        for polygon in pred_mpoly_l:
            pred_l_center = polygon.centroid
            #pred_Centroid_L[frameNumber] = pred_l_center
            print("pred_Centroid_L:", pred_l_center)

        for polygon in gt_mpoly_r:
            gt_r_center = polygon.centroid
            #gt_Centroid_R[frameNumber] = gt_r_center
            print("gt_Centroid_R:", gt_r_center)

        for polygon in pred_mpoly_r:
            pred_r_center = polygon.centroid
            #pred_Centroid_R[frameNumber] = pred_r_center
            print("pred_Centroid_R:", pred_r_center)

        # finding distance between graspers of gt and pred
        pred_d = pred_l_center.distance(pred_r_center)
        pred_dist[frameNumber] = pred_d
        print("PRED_DIST", pred_d)

        gt_d = gt_l_center.distance(gt_r_center)
        gt_dist[frameNumber] = gt_d
        print("GT_DIST", gt_d)


            print("proc", os.path.basename(TrialRoot), "count:", frameNum)
        print(gt_Centroid_L)
        print(pred_Centroid_L)
        print(gt_Centroid_R)
        print(pred_Centroid_R)
        print(pred_dist)
        print(gt_dist)
        print("done processing")
        return gt_Centroid_L, gt_Centroid_R, pred_Centroid_L, pred_Centroid_R, gt_dist, pred_dist



        ### BREAK ###

        # plot location of grasper center on 2D plot
        # over time
        # plotting distance between vs. time

    def plotGrasperDist(self):
        gt_dist = {}
        pred_dist = {}
        gt_Centroid_L, gt_Centroid_R, pred_Centroid_L, pred_Centroid_R, gt_dist, pred_dist = self.GetGrasperDist()


        # for gt
        # create dataframe
        gt_dataframe = pd.DataFrame({'frame_number': gt_dist.keys(),
                                       'distance': gt_dist.values()})

        # for pred
        # create dataframe
        pred_dataframe = pd.DataFrame({'frame_number': pred_dist.keys(),
                                  'distance': pred_dist.values()})

        # for gt?

        # for pred
        for n in pred_dist.keys(): # for each frame number
            # plot entire graph
            # Plotting the time series of given dataframe
            plt.plot(pred_dataframe.frame_number, pred_dataframe.distance, color='blue')

            # Giving title to the chart using plt.title
            plt.title('Distance Between Graspers by Frames')

            # Providing x and y label to the chart
            plt.xlabel('Frame')
            plt.ylabel('Distance Between Graspers')

            # draw vertical line at each frame number
            # save each graph
            # only one line may be specified; full height
            line = plt.axvline(x=n, color='red', label='axvline - full height')
            # frame number test
            f_text = plt.text(5050, 530, "Frame "+ str(n))

            # change savefig default directory output
            # to: in task (Suturing), folder grasper_plot_images, in appropriate Trial folder
            plot_filename = 'plot_frame_' + str(n).zfill(4) + '.png' # add leading zeros
            plot_file_path = os.path.join(gplotRoot, plot_filename)
            #print("PLOT_FILE_PATH: ", plot_file_path)

            #plt.savefig(plot_file_path)
            line.remove()
            f_text.remove()

            # here: have saved plots for each frame





        ### BREAK ###

        # puts plot and raw images side by side
        # iterates over all trials in a task

    def plotBesideImage(self):
        FilenamesInTask = ["Suturing_S02_T01"]  # self.getFilenamesinTask()
        for Trial in FilenamesInTask:
            # DLImagesRoot = os.path.join(self.CWD, self.task, "deeplab_labeled_images", Trial)
            TrialRoot = os.path.join(self.imagesDir, Trial)
            # TrialRoot = os.path.join(self.plotImagesDir, Trial)
            frameNum = 0
            for root, dirs, files in os.walk(TrialRoot):
                files.sort()
                for file in files:
                    if "frame" not in file:
                        continue
                    frameNum += 1
                    imageRoot = root
                    frameNumber = int(file.replace(".png", "").split("_")[1])
                    trialFname = os.path.basename(root)
                    imageFName = os.path.join(imageRoot, file)

                    gplotRoot = os.path.join(self.plotImagesDir, trialFname)
                    plot_file = 'plot_' + file
                    gplotFName = os.path.join(self.plotImagesDir, trialFname, plot_file)
                    #print("GPLOTFNAME:", gplotFName)

                    plotImageOutputRoot = os.path.join(self.plotNextToImagesDir, trialFname)
                    plotImageOutputFName = os.path.join(self.plotNextToImagesDir, trialFname, file)
                    print("plotImageOutputFName:", plotImageOutputFName)

                    # graph_path = os.path.join(self.CWD, 'grasper_distance_plot.png')
                    # for n in frame number:
                    im1 = cv.imread(imageFName) # imageFName raw image? outputFName is labelled imaged
                    print("IMAGEFNAME:", imageFName)
                    im2 = cv.imread(gplotFName) # grasper plot
                    print("GPLOTFNAME:", gplotFName)

                    # gplotFName and imageFName size: (480, 640, 3); outputFName size: (389, 488, 3)
                    print(im1.shape)
                    print(im2.shape)

                    # concatenate images of same size: gplotFName and imageFName
                    img_plot = cv.hconcat([im1, im2])
                    # cv.imshow('image and plot', img_plot)
                    # cv.waitKey(0);
                    #cv.imwrite(plotImageOutputFName, img_plot)


    def getContourData(self):
        DeeplabVIARings = {}
        DeeplabVIAPoints = {}
        DeeplabVIAFrames = {}

        for root, dirs, files in os.walk(self.contourDir):
            files.sort()
            for file in files:
                if ".DS_Store" in file:
                    continue
                fileID = file.replace(".json", "")
                # if "frame" not in file:
                label_class = os.path.basename(root)
                if "ring" in label_class:
                    VIAFname = os.path.join(root, file)
                    J = utils.VIARingJSON(VIAFname)
                    if fileID not in DeeplabVIARings.keys():
                        DeeplabVIARings[fileID] = {}
                    # if fileID not in DeeplabVIAFrames.keys():
                    #    DeeplabVIAFrames[file.replace(".json","")] = {}
                    ringNames = ["Ring_4", "Ring_5", "Ring_6", "Ring_7"]
                    R4Dict, R5Dict, R6Dict, R7Dict = J.getRingsPoints()
                    # [R4Frames,R5Frames,R6Frames,R7Frames] = J.getFrameNumbers()
                    DeeplabVIARings[fileID]["Ring_4"] = R4Dict
                    DeeplabVIARings[fileID]["Ring_5"] = R5Dict
                    DeeplabVIARings[fileID]["Ring_6"] = R6Dict
                    DeeplabVIARings[fileID]["Ring_7"] = R7Dict
                    # DeeplabVIARings[file.replace(".json","")][ringClass] = J.getFrameNumbers()
                    print("\t Load data: dl_rings", file, label_class)
                else:
                    VIAFname = os.path.join(root, file)
                    J = utils.VIAPolyJSON(VIAFname)
                    class_name = J.getClassKey(label_class)
                    if fileID not in DeeplabVIAPoints.keys():
                        DeeplabVIAPoints[fileID] = {}
                    if fileID not in DeeplabVIAFrames.keys():
                        DeeplabVIAFrames[fileID] = {}
                    DeeplabVIAPoints[fileID][class_name] = J.getDataDict()
                    DeeplabVIAFrames[fileID][class_name] = J.getFrameNumbers()
                    print("\t Load data: dl_points", file, label_class)
        return DeeplabVIAPoints, DeeplabVIAFrames, DeeplabVIARings

    def getFilenamesinTask(self):
        Dirs = []
        oldRoot = ""
        for root, dirs, files in os.walk(self.imagesDir):
            Dirs = dirs
            oldRoot = root
            break
        return Dirs


    def GetCommonShapes(self, gtPolygons, gtKeypoints, SingleThreadPoints, polylineSeries,
                        LgrasperPoints, RgrasperPoints):
    # def GetCommonShapes(self, gtPolygons, gtKeypoints, SingleThreadPoints, polylineSeries, ThreadContours,
    #                         LgrasperPoints, RgrasperPoints):
        RG_Group_gt = geo.MultiPolygon(
            [geo.Polygon([(poly[i], poly[i + 1]) for i in range(0, len(poly), 2)]) for poly in
             gtPolygons["Right Grasper"]]) if "Right Grasper" in gtPolygons.keys() else []
        LG_Group_gt = geo.MultiPolygon(
            [geo.Polygon([(poly[i], poly[i + 1]) for i in range(0, len(poly), 2)]) for poly in
             gtPolygons["Left Grasper"]]) if "Left Grasper" in gtPolygons.keys() else []

        polys = []
        for i in range(len(polylineSeries)):
            l = len(polylineSeries)
            SingleThreadX = []
            SingleThreadY = []
            points = []
            for j in range(0, len(polylineSeries[i]), 2):
                SingleThreadX.append(polylineSeries[i][j])
                SingleThreadY.append(polylineSeries[i][j + 1])
                points.append((polylineSeries[i][j], polylineSeries[i][j + 1]))
            if (len(points) >= 3):
                currPoly = geo.Polygon(geo.LineString([point for point in points]))
                polys.append(currPoly)

        # SingleThreadPoints = [(SingleThreadX[i],SingleThreadY[i]) for i in range(len(SingleThreadX))]

        # T_Group_gt = geo.MultiPolygon(polys)

        for poly in LgrasperPoints:
            if (len(poly) < 3):
                LgrasperPoints.remove(poly)

        LG_dl = geo.MultiPolygon([geo.Polygon(poly) for poly in LgrasperPoints])
        for poly in RgrasperPoints:
            if (len(poly) < 3):
                RgrasperPoints.remove(poly)
        RG_dl = geo.MultiPolygon([geo.Polygon(poly) for poly in RgrasperPoints])

        # threadPolys = []
        # for k in range(len(ThreadContours)):
        #     if (len(ThreadContours[k]) > 2):
        #         cnt = ThreadContours[k]
        #         threadPolys.append(geo.Polygon([(c[0][0], c[0][1]) for c in cnt]))
        # T_dl = geo.MultiPolygon(threadPolys)

        pred = [LG_dl, RG_dl] #, T_dl]
        gt = [LG_Group_gt, RG_Group_gt] #, T_Group_gt]
        return pred, gt


class VideoInterface:

    def __init__(self, task):
        self.CWD = os.path.dirname(os.path.realpath(__file__))
        self.task = task
        self.imagesDir = os.path.join(self.CWD, task, "images")
        # self.deeplabOutputDir = os.path.join(self.CWD, task, "deeplab_labeled_images")
        # self.OS = "windows"

    def makevideos(self):
        Dirs = ["Suturing_S02_T01"]  # self.getFilenamesinTask()  # These are all the trial we'll generate context labels for. We get this list from the images folder
        print("Trials:", "Suturing_S02_T01")  # FilenamesInTask)
        '''
        Dirs = []
        for root, dirs, files in os.walk(self.imagesDir):
            Dirs = dirs
            break
        print("Trials:", Dirs)
        '''
        TrialNum = 0
        for Trial in Dirs:
            TrialRoot = os.path.join(self.CWD, self.task, "grasper_plot_sidebyside", Trial)

            img_array = []
            for filename in sorted(glob.glob(TrialRoot + '/*.png')):
                img = cv.imread(filename)
                height, width, layers = img.shape
                size = (width, height)
                img_array.append(img)

            out = cv.VideoWriter(self.CWD + '/plot_' + Trial + '.mp4', cv.VideoWriter_fourcc(*'mp4v'), 15, size)

            for i in range(len(img_array)):
                for j in range(3):
                    out.write(img_array[i])

            out.release()
            print("Saved Video", Trial)
            TrialNum += 1

        print("Processed ", TrialNum, "trials")


main()