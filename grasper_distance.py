import os, sys
import utils
import pathlib
from scipy import ndimage
import cv2 as cv
from shapely import geometry as geo
from shapely.ops import unary_union
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.artist import Artist
from matplotlib.offsetbox import AnchoredText

from shapely.ops import polygonize
import math
from matplotlib.patches import Rectangle
import pandas as pd
import glob


def main():
    dir = os.getcwd()
    task = "Suturing"
    # try:
    #     task = sys.argv[1]
    # except:
    #     print("Error: no task provided", "Usage: python deeplab_nokin_context_v3.py <task>", "Default Task" + task)

    I = Iterator(task)

    #I.closestGrasperDist()

    # get series of images of grasper distance plots beside images
    # I.grasperDistScript()
    # I.GrasperDistImages(SAVE=False)

    # get series of images of centers of graspers
    I.GrasperCenterImages(SAVE=False)

    # turn series of images into a video
    V = VideoInterface(task)
    # V.makevideos()

    quit();


class Iterator:

    def __init__(self, task):
        self.CWD = os.path.dirname(os.path.realpath(__file__))
        self.task = task
        self.plotImagesDir = os.path.join(self.CWD, task, "grasper_plot_images")
        self.plotNextToImagesDir = os.path.join(self.CWD, task, "grasper_plot_sidebyside")
        self.centerImagesDir = os.path.join(self.CWD, task, "center_images")
        self.imagesDir = os.path.join(self.CWD, task, "images")
        self.cogitoDir = os.path.join(self.CWD, task, "annotations")
        self.cogitoOutputDir = os.path.join(self.CWD, task, "cogito_labeled_images")
        self.context_output = os.path.join(self.CWD, task, "vis_context_labels_v5")
        self.deeplabOutputDir = os.path.join(self.CWD, task, "deeplab_labeled_images_test")
        self.drawContourDir = os.path.join(self.CWD, task, "draw_contour_images")
        self.ctxConsensusDir = os.path.join(self.CWD, task, "ctx_consensus")
        self.ctxSurgeonDir = os.path.join(self.CWD, task, "ctx_surgeon")
        self.ctxPredDir = os.path.join(self.CWD, task, "ctx_output")
        self.tissueDir = os.path.join(self.CWD, task,
                                      "tissue_keypoints")  # contains VIA labels for the points on the canvas (Suturing)
        self.grasperJawDir = os.path.join(self.CWD, task,
                                          "grasper_jaw_keypoints")  # contains VIA labels for the grasper jaw points
        self.contourDir = os.path.join(self.CWD, task,
                                       "contour_points")  # All of the contour points generated by contours.py

        self.OS = "windows"

    # get closest grasper distance
    def closestGrasperDist(self):
        # get grasper contour data
        # (from the output of contours.py)
        DeeplabVIAPoints, DeeplabVIAFrames, DeeplabVIARings = self.getContourData()

        # need to generate for all trials and all tasks
        # but for now focus on Suturing_S02_T01
        FilenamesInTask = [
            "Suturing_S02_T01"]  # self.getFilenamesinTask()  # will get all the trials (from the images folder)
        print("Trials:", "Suturing_S02_T01")  # FilenamesInTask)

        for Trial in FilenamesInTask:
            # dictionary {frame_number : centroid point}
            gt_Centroid_L = {}
            gt_Centroid_R = {}
            pred_Centroid_L = {}
            pred_Centroid_R = {}
            gt_dist = {}
            pred_dist = {}

            TrialRoot = os.path.join(self.imagesDir, Trial)
            ctxFName = os.path.join(self.ctxConsensusDir, Trial + ".txt")
            ctxPredFName = os.path.join(self.context_output, Trial + ".txt")
            frameNum = 0
            for root, dirs, files in os.walk(TrialRoot):
                files.sort()
                for file in files:
                    if "frame" not in file:
                        continue
                    frameNum += 1
                    imageRoot = root
                    frameNumber = int(file.replace(".png", "").split("_")[1])
                    trialFname = os.path.basename(root)
                    imageFName = os.path.join(imageRoot, file)
                    cogitoRoot = root.replace("images", "annotations")
                    cogitoFName = os.path.join(cogitoRoot, utils.imageToJSON(file))
                    outputRoot = os.path.join(self.deeplabOutputDir, trialFname)
                    # outputFName = os.path.join(self.deeplabOutputDir, trialFname, file)

                    gplotRoot = os.path.join(self.plotImagesDir, trialFname)
                    plot_file = 'plot_' + file
                    gplotFName = os.path.join(self.plotImagesDir, trialFname, plot_file)
                    # print("GPLOTFNAME:", gplotFName)

                    annotationRoot = root.replace("images", "annotations")
                    annotationFile = os.path.join(annotationRoot, utils.imageToJSON(file))

                    # All _dl_points contains the contours that are applicable for this Task and Trial combo
                    All_dl_points = DeeplabVIAPoints[trialFname]  # ["class"]["frame"] = list of points

                    # Getting particular contours (array of points)
                    try:
                        LgrasperPoints = All_dl_points["dl_grasper_L"][str(frameNumber)]
                    except Exception as e:
                        print(e, "in LgrasperPoints")
                        LgrasperPoints = {}

                    try:
                        RgrasperPoints = All_dl_points["dl_grasper_R"][str(frameNumber)]
                    except Exception as e:
                        print(e, "in RgrasperPoints")
                        RgrasperPoints = {}

                    CtxI = utils.ContextInterface2(ctxFName)
                    J = utils.JSONInterface(annotationFile)

                    # gtPolygons are Ground Truth contour points for the cogito labels
                    gtPolygons = J.getPolygonsDict();  # graspers only in KT, (don't need needle mask)
                    # print(type(gtPolygons)) # dict
                    # print(gtPolygons) # tool : points

                    # gtKeypoints are Ground Truth points from cogito labels
                    gtKeypoints = J.getKeyPointsDict();  # not needed, only for GetCommonShapes function
                    cn, polylineSeries = J.getPolyLines();  # not needed
                    SingleThreadX = []
                    SingleThreadY = []
                    for i in range(len(polylineSeries)):
                        l = len(polylineSeries)
                        for j in range(0, len(polylineSeries[i]), 2):
                            SingleThreadX.append(polylineSeries[i][j])
                            SingleThreadY.append(polylineSeries[i][j + 1])
                    SingleThreadPoints = [(SingleThreadX[i], SingleThreadY[i]) for i in range(len(SingleThreadX))]

                    if (not os.path.isdir(outputRoot)):
                        path = pathlib.Path(outputRoot)
                        path.mkdir(parents=True, exist_ok=True)

                    # pred has all the polygons from Zoey's masks
                    # gt has all the polygons from cogito
                    pred, gt = self.GetCommonShapes(gtPolygons, gtKeypoints, SingleThreadPoints, polylineSeries,
                                                    LgrasperPoints, RgrasperPoints)

                    # function for getting grasper distance? no; need frame number

                    # multipolygons in left and right graspers
                    gt_mpoly_l = gt[0]
                    gt_mpoly_r = gt[1]

                    pred_mpoly_l = pred[0]
                    pred_mpoly_r = pred[1]

                    # print("PRED_MPOLY_L:", pred_mpoly_l)
                    # print(type(pred_mpoly_l))

                    # find grasper center
                    for polygon in gt_mpoly_l:
                        gt_l_center = polygon.centroid
                        gt_Centroid_L[frameNumber] = gt_l_center
                        print("gt_Centroid_L:", gt_l_center)

                    for polygon in pred_mpoly_l:
                        pred_l_center = polygon.centroid
                        pred_Centroid_L[frameNumber] = pred_l_center
                        print("pred_Centroid_L:", pred_l_center)

                    for polygon in gt_mpoly_r:
                        gt_r_center = polygon.centroid
                        gt_Centroid_R[frameNumber] = gt_r_center
                        print("gt_Centroid_R:", gt_r_center)

                    for polygon in pred_mpoly_r:
                        pred_r_center = polygon.centroid
                        pred_Centroid_R[frameNumber] = pred_r_center
                        print("pred_Centroid_R:", pred_r_center)

                    # finding distance between graspers of gt and pred
                    pred_d = pred_l_center.distance(pred_r_center)
                    pred_dist[frameNumber] = pred_d
                    print("PRED_DIST", pred_d)

                    gt_d = gt_l_center.distance(gt_r_center)
                    gt_dist[frameNumber] = gt_d
                    print("GT_DIST", gt_d)

            # closest gt and pred grasper distance for each trial
            pred_closest_dist_fn = min(pred_dist, key=pred_dist.get)
            pred_closest_dist = pred_dist[pred_closest_dist_fn]
            gt_closest_dist_fn = min(gt_dist, key=gt_dist.get)
            gt_closest_dist = gt_dist[gt_closest_dist_fn]
            print("Closest grasper distance (pred) :", pred_closest_dist, "at", pred_closest_dist_fn)
            print("Closest grasper distance (gt) :", gt_closest_dist, "at", gt_closest_dist_fn)

    # original script
    # produces plots showing grasper distance over time (at a frame number)
    def grasperDistScript(self):
        # get grasper contour data
        # (from the output of contours.py)
        DeeplabVIAPoints, DeeplabVIAFrames, DeeplabVIARings = self.getContourData()

        # need to generate for all trials and all tasks
        # but for now focus on Suturing_S02_T01
        FilenamesInTask = [
            "Suturing_S02_T01"]  # self.getFilenamesinTask()  # will get all the trials (from the images folder)
        print("Trials:", "Suturing_S02_T01")  # FilenamesInTask)

        for Trial in FilenamesInTask:
            # dictionary {frame_number : centroid point}
            gt_Centroid_L = {}
            gt_Centroid_R = {}
            pred_Centroid_L = {}
            pred_Centroid_R = {}
            gt_dist = {}
            pred_dist = {}

            TrialRoot = os.path.join(self.imagesDir, Trial)
            ctxFName = os.path.join(self.ctxConsensusDir, Trial + ".txt")
            ctxPredFName = os.path.join(self.context_output, Trial + ".txt")
            frameNum = 0
            for root, dirs, files in os.walk(TrialRoot):
                files.sort()
                for file in files:
                    if "frame" not in file:
                        continue
                    frameNum += 1
                    imageRoot = root
                    frameNumber = int(file.replace(".png", "").split("_")[1])
                    trialFname = os.path.basename(root)
                    imageFName = os.path.join(imageRoot, file)
                    cogitoRoot = root.replace("images", "annotations")
                    cogitoFName = os.path.join(cogitoRoot, utils.imageToJSON(file))
                    outputRoot = os.path.join(self.deeplabOutputDir, trialFname)
                    # outputFName = os.path.join(self.deeplabOutputDir, trialFname, file)

                    gplotRoot = os.path.join(self.plotImagesDir, trialFname)
                    plot_file = 'plot_' + file
                    gplotFName = os.path.join(self.plotImagesDir, trialFname, plot_file)
                    # print("GPLOTFNAME:", gplotFName)

                    annotationRoot = root.replace("images", "annotations")
                    annotationFile = os.path.join(annotationRoot, utils.imageToJSON(file))

                    # All _dl_points contains the contours that are applicable for this Task and Trial combo
                    All_dl_points = DeeplabVIAPoints[trialFname]  # ["class"]["frame"] = list of points

                    # Getting particular contours (array of points)
                    try:
                        LgrasperPoints = All_dl_points["dl_grasper_L"][str(frameNumber)]
                    except Exception as e:
                        print(e, "in LgrasperPoints")
                        LgrasperPoints = {}

                    try:
                        RgrasperPoints = All_dl_points["dl_grasper_R"][str(frameNumber)]
                    except Exception as e:
                        print(e, "in RgrasperPoints")
                        RgrasperPoints = {}

                    CtxI = utils.ContextInterface2(ctxFName)
                    J = utils.JSONInterface(annotationFile)

                    # gtPolygons are Ground Truth contour points for the cogito labels
                    gtPolygons = J.getPolygonsDict();  # graspers only in KT, (don't need needle mask)
                    # print(type(gtPolygons)) # dict
                    # print(gtPolygons) # tool : points

                    # gtKeypoints are Ground Truth points from cogito labels
                    gtKeypoints = J.getKeyPointsDict();  # not needed, only for GetCommonShapes function
                    cn, polylineSeries = J.getPolyLines();  # not needed
                    SingleThreadX = []
                    SingleThreadY = []
                    for i in range(len(polylineSeries)):
                        l = len(polylineSeries)
                        for j in range(0, len(polylineSeries[i]), 2):
                            SingleThreadX.append(polylineSeries[i][j])
                            SingleThreadY.append(polylineSeries[i][j + 1])
                    SingleThreadPoints = [(SingleThreadX[i], SingleThreadY[i]) for i in range(len(SingleThreadX))]

                    if (not os.path.isdir(outputRoot)):
                        path = pathlib.Path(outputRoot)
                        path.mkdir(parents=True, exist_ok=True)

                    # pred has all of the polygons from Zoey's masks
                    # gt has all of the polygons from cogito
                    pred, gt = self.GetCommonShapes(gtPolygons, gtKeypoints, SingleThreadPoints, polylineSeries,
                                                    LgrasperPoints, RgrasperPoints)

                    #pd, gd = self.GetGrasperDist(pred, gt)
                    ## aka getgrasperdist

                    # multipolygons in left and right graspers
                    gt_mpoly_l = gt[0]
                    gt_mpoly_r = gt[1]

                    pred_mpoly_l = pred[0]
                    pred_mpoly_r = pred[1]

                    # print("PRED_MPOLY_L:", pred_mpoly_l)
                    # print(type(pred_mpoly_l))

                    # find grasper center
                    for polygon in gt_mpoly_l:
                        gt_l_center = polygon.centroid
                        gt_Centroid_L[frameNumber] = gt_l_center
                        print("gt_Centroid_L:", gt_l_center)

                    for polygon in pred_mpoly_l:
                        pred_l_center = polygon.centroid
                        pred_Centroid_L[frameNumber] = pred_l_center
                        print("pred_Centroid_L:", pred_l_center)

                    for polygon in gt_mpoly_r:
                        gt_r_center = polygon.centroid
                        gt_Centroid_R[frameNumber] = gt_r_center
                        print("gt_Centroid_R:", gt_r_center)

                    for polygon in pred_mpoly_r:
                        pred_r_center = polygon.centroid
                        pred_Centroid_R[frameNumber] = pred_r_center
                        print("pred_Centroid_R:", pred_r_center)

                    # finding distance between graspers of gt and pred
                    pred_d = pred_l_center.distance(pred_r_center)
                    pred_dist[frameNumber] = pred_d
                    print("PRED_DIST", pred_d)

                    gt_d = gt_l_center.distance(gt_r_center)
                    gt_dist[frameNumber] = gt_d
                    print("GT_DIST", gt_d)

            print("proc", os.path.basename(TrialRoot), "count:", frameNum)

            # need centers and distances for each trial
            print(gt_Centroid_L)
            print(pred_Centroid_L)
            print(gt_Centroid_R)
            print(pred_Centroid_R)
            print(pred_dist)
            print(gt_dist)
            print("done processing")
            #return gt_Centroid_L, gt_Centroid_R, pred_Centroid_L, pred_Centroid_R, gt_dist, pred_dist

            ### BREAK ###

            # plot location of grasper center on 2D plot
            # over time
            # plotting distance between vs. time

            #gt_dist = {}
            #pred_dist = {}
            #gt_Centroid_L, gt_Centroid_R, pred_Centroid_L, pred_Centroid_R, gt_dist, pred_dist = self.GetGrasperDist()

            # for gt
            # create dataframe
            gt_dataframe = pd.DataFrame({'frame_number': gt_dist.keys(),
                                         'distance': gt_dist.values()})

            # for pred
            # create dataframe
            pred_dataframe = pd.DataFrame({'frame_number': pred_dist.keys(),
                                           'distance': pred_dist.values()})

            # for gt?

            # for pred
            for n in pred_dist.keys():  # for each frame number
                # plot entire graph
                # Plotting the time series of given dataframe
                plt.plot(pred_dataframe.frame_number, pred_dataframe.distance, color='blue')

                # Giving title to the chart using plt.title
                plt.title('Distance Between Graspers by Frames')

                # Providing x and y label to the chart
                plt.xlabel('Frame')
                plt.ylabel('Distance Between Graspers')

                # draw vertical line at each frame number
                # save each graph
                # only one line may be specified; full height
                line = plt.axvline(x=n, color='red', label='axvline - full height')
                # frame number test
                f_text = plt.text(5050, 530, "Frame " + str(n))

                # change savefig default directory output
                # to: in task (Suturing), folder grasper_plot_images, in appropriate Trial folder
                plot_filename = 'plot_frame_' + str(n).zfill(4) + '.png'  # add leading zeros
                plot_file_path = os.path.join(gplotRoot, plot_filename)
                # print("PLOT_FILE_PATH: ", plot_file_path)

                # plt.show()
                # plt.savefig(plot_file_path)
                line.remove()
                f_text.remove()

                # by here: should have saved plots for each frame
                # next : call function to add image next to graph

                ### BREAK ###

                # puts plot and raw images side by side
                # iterates over all trials in a task


    # refactored version
    def GrasperDistImages(self, SAVE=False):
        # get grasper contour data
        # (from the output of contours.py)
        DeeplabVIAPoints, DeeplabVIAFrames, DeeplabVIARings = self.getContourData()

        # need to generate for all trials and all tasks
        # but for now focus on Suturing_S02_T01
        FilenamesInTask = [
            "Suturing_S02_T01"]  # self.getFilenamesinTask()  # will get all the trials (from the images folder)
        print("Trials:", "Suturing_S02_T01")  # FilenamesInTask)

        for Trial in FilenamesInTask:
            # dictionary {frame_number : centroid point}
            gt_Centroid_L = {}
            gt_Centroid_R = {}
            pred_Centroid_L = {}
            pred_Centroid_R = {}
            gt_dist = {}
            pred_dist = {}

            TrialRoot = os.path.join(self.imagesDir, Trial)
            ctxFName = os.path.join(self.ctxConsensusDir, Trial + ".txt")
            ctxPredFName = os.path.join(self.context_output, Trial + ".txt")
            frameNum = 0
            for root, dirs, files in os.walk(TrialRoot):
                files.sort()
                for file in files:
                    if "frame" not in file:
                        continue
                    frameNum += 1
                    imageRoot = root
                    frameNumber = int(file.replace(".png", "").split("_")[1])
                    trialFname = os.path.basename(root)
                    imageFName = os.path.join(imageRoot, file)
                    cogitoRoot = root.replace("images", "annotations")
                    cogitoFName = os.path.join(cogitoRoot, utils.imageToJSON(file))
                    outputRoot = os.path.join(self.deeplabOutputDir, trialFname)
                    # outputFName = os.path.join(self.deeplabOutputDir, trialFname, file)

                    gplotRoot = os.path.join(self.plotImagesDir, trialFname)
                    plot_file = 'plot_' + file
                    gplotFName = os.path.join(self.plotImagesDir, trialFname, plot_file)
                    # print("GPLOTFNAME:", gplotFName)

                    annotationRoot = root.replace("images", "annotations")
                    annotationFile = os.path.join(annotationRoot, utils.imageToJSON(file))

                    # All _dl_points contains the contours that are applicable for this Task and Trial combo
                    All_dl_points = DeeplabVIAPoints[trialFname]  # ["class"]["frame"] = list of points

                    # Getting particular contours (array of points)
                    try:
                        LgrasperPoints = All_dl_points["dl_grasper_L"][str(frameNumber)]
                    except Exception as e:
                        print(e, "in LgrasperPoints")
                        LgrasperPoints = {}

                    try:
                        RgrasperPoints = All_dl_points["dl_grasper_R"][str(frameNumber)]
                    except Exception as e:
                        print(e, "in RgrasperPoints")
                        RgrasperPoints = {}

                    CtxI = utils.ContextInterface2(ctxFName)
                    J = utils.JSONInterface(annotationFile)

                    # gtPolygons are Ground Truth contour points for the cogito labels
                    gtPolygons = J.getPolygonsDict();  # graspers only in KT, (don't need needle mask)
                    # print(type(gtPolygons)) # dict
                    # print(gtPolygons) # tool : points

                    # gtKeypoints are Ground Truth points from cogito labels
                    gtKeypoints = J.getKeyPointsDict();  # not needed, only for GetCommonShapes function
                    cn, polylineSeries = J.getPolyLines();  # not needed
                    SingleThreadX = []
                    SingleThreadY = []
                    for i in range(len(polylineSeries)):
                        l = len(polylineSeries)
                        for j in range(0, len(polylineSeries[i]), 2):
                            SingleThreadX.append(polylineSeries[i][j])
                            SingleThreadY.append(polylineSeries[i][j + 1])
                    SingleThreadPoints = [(SingleThreadX[i], SingleThreadY[i]) for i in range(len(SingleThreadX))]

                    if (not os.path.isdir(outputRoot)):
                        path = pathlib.Path(outputRoot)
                        path.mkdir(parents=True, exist_ok=True)

                    # pred has all the polygons from Zoey's masks
                    # gt has all the polygons from cogito
                    pred, gt = self.GetCommonShapes(gtPolygons, gtKeypoints, SingleThreadPoints, polylineSeries,
                                                    LgrasperPoints, RgrasperPoints)

                    # function for getting grasper distance? no; need frame number

                    # multipolygons in left and right graspers
                    gt_mpoly_l = gt[0]
                    gt_mpoly_r = gt[1]

                    pred_mpoly_l = pred[0]
                    pred_mpoly_r = pred[1]

                    # print("PRED_MPOLY_L:", pred_mpoly_l)
                    # print(type(pred_mpoly_l))

                    # find grasper center
                    for polygon in gt_mpoly_l:
                        gt_l_center = polygon.centroid
                        gt_Centroid_L[frameNumber] = gt_l_center
                        print("gt_Centroid_L:", gt_l_center)

                    for polygon in pred_mpoly_l:
                        pred_l_center = polygon.centroid
                        pred_Centroid_L[frameNumber] = pred_l_center
                        print("pred_Centroid_L:", pred_l_center)

                    for polygon in gt_mpoly_r:
                        gt_r_center = polygon.centroid
                        gt_Centroid_R[frameNumber] = gt_r_center
                        print("gt_Centroid_R:", gt_r_center)

                    for polygon in pred_mpoly_r:
                        pred_r_center = polygon.centroid
                        pred_Centroid_R[frameNumber] = pred_r_center
                        print("pred_Centroid_R:", pred_r_center)

                    # finding distance between graspers of gt and pred
                    pred_d = pred_l_center.distance(pred_r_center)
                    pred_dist[frameNumber] = pred_d
                    print("PRED_DIST", pred_d)

                    gt_d = gt_l_center.distance(gt_r_center)
                    gt_dist[frameNumber] = gt_d
                    print("GT_DIST", gt_d)

            ### BREAK ###

            # PLOTTING
            # one video for each trial, need plots of each frame

            # function for plotting
            self.plotGrasperDist(gt_dist, pred_dist, gplotRoot)  # save option? choose gt or pred?

            # function to add images beside plot
            # need to have saved plot images from plotGrasperDist()
            self.plotBesideImage()  # save option?

            print("proc", os.path.basename(TrialRoot), "count:", frameNum)

    def GrasperCenterImages(self, SAVE=False):
        # get grasper contour data
        # (from the output of contours.py)
        DeeplabVIAPoints, DeeplabVIAFrames, DeeplabVIARings = self.getContourData()

        # need to generate for all trials and all tasks
        # but for now focus on Suturing_S02_T01
        FilenamesInTask = [
            "Suturing_S02_T01"]  # self.getFilenamesinTask()  # will get all the trials (from the images folder)
        print("Trials:", "Suturing_S02_T01")  # FilenamesInTask)

        for Trial in FilenamesInTask:
            # dictionary {frame_number : centroid point}
            gt_Centroid_L = {}
            gt_Centroid_R = {}
            pred_Centroid_L = {}
            pred_Centroid_R = {}

            TrialRoot = os.path.join(self.imagesDir, Trial)
            ctxFName = os.path.join(self.ctxConsensusDir, Trial + ".txt")
            ctxPredFName = os.path.join(self.context_output, Trial + ".txt")
            frameNum = 0
            for root, dirs, files in os.walk(TrialRoot):
                files.sort()
                for file in files:
                    if "frame" not in file:
                        continue
                    frameNum += 1
                    imageRoot = root
                    frameNumber = int(file.replace(".png", "").split("_")[1])
                    trialFname = os.path.basename(root)
                    imageFName = os.path.join(imageRoot, file)
                    cogitoRoot = root.replace("images", "annotations")
                    cogitoFName = os.path.join(cogitoRoot, utils.imageToJSON(file))
                    outputRoot = os.path.join(self.deeplabOutputDir, trialFname)
                    # outputFName = os.path.join(self.deeplabOutputDir, trialFname, file)
                    drawFName = os.path.join(self.drawContourDir, trialFname, file)

                    gplotRoot = os.path.join(self.plotImagesDir, trialFname)
                    plot_file = 'plot_' + file
                    gplotFName = os.path.join(self.plotImagesDir, trialFname, plot_file)
                    # print("GPLOTFNAME:", gplotFName)

                    annotationRoot = root.replace("images", "annotations")
                    annotationFile = os.path.join(annotationRoot, utils.imageToJSON(file))

                    # All _dl_points contains the contours that are applicable for this Task and Trial combo
                    All_dl_points = DeeplabVIAPoints[trialFname]  # ["class"]["frame"] = list of points

                    # Getting particular contours (array of points)
                    try:
                        LgrasperPoints = All_dl_points["dl_grasper_L"][str(frameNumber)]
                        print("LgrasperPoints:", LgrasperPoints)
                    except Exception as e:
                        print(e, "in LgrasperPoints")
                        LgrasperPoints = {}

                    try:
                        RgrasperPoints = All_dl_points["dl_grasper_R"][str(frameNumber)]
                    except Exception as e:
                        print(e, "in RgrasperPoints")
                        RgrasperPoints = {}

                    CtxI = utils.ContextInterface2(ctxFName)
                    J = utils.JSONInterface(annotationFile)

                    # gtPolygons are Ground Truth contour points for the cogito labels
                    gtPolygons = J.getPolygonsDict();  # graspers only in KT, (don't need needle mask)
                    # print(type(gtPolygons)) # dict
                    # print(gtPolygons) # tool : points

                    # gtKeypoints are Ground Truth points from cogito labels
                    gtKeypoints = J.getKeyPointsDict();  # not needed, only for GetCommonShapes function
                    cn, polylineSeries = J.getPolyLines();  # not needed
                    SingleThreadX = []
                    SingleThreadY = []
                    for i in range(len(polylineSeries)):
                        l = len(polylineSeries)
                        for j in range(0, len(polylineSeries[i]), 2):
                            SingleThreadX.append(polylineSeries[i][j])
                            SingleThreadY.append(polylineSeries[i][j + 1])
                    SingleThreadPoints = [(SingleThreadX[i], SingleThreadY[i]) for i in range(len(SingleThreadX))]

                    if (not os.path.isdir(outputRoot)):
                        path = pathlib.Path(outputRoot)
                        path.mkdir(parents=True, exist_ok=True)

                    # pred has all the polygons from Zoey's masks
                    # gt has all the polygons from cogito
                    pred, gt = self.GetCommonShapes(gtPolygons, gtKeypoints, SingleThreadPoints, polylineSeries,
                                                    LgrasperPoints, RgrasperPoints)

                    # function for getting grasper distance? no; need frame number

                    # multipolygons in left and right graspers
                    gt_mpoly_l = gt[0]
                    gt_mpoly_r = gt[1]

                    pred_mpoly_l = pred[0]
                    pred_mpoly_r = pred[1]

                    print("PRED_MPOLY_L:", pred_mpoly_l)
                    print(type(pred_mpoly_l))

                    # find grasper center
                    for polygon in gt_mpoly_l:
                        print("POLYGON:", polygon)
                        gt_l_center = polygon.centroid
                        gt_Centroid_L[frameNumber] = gt_l_center
                        print("gt_Centroid_L:", gt_l_center)

                    for polygon in pred_mpoly_l:
                        pred_l_center = polygon.centroid
                        pred_Centroid_L[frameNumber] = pred_l_center
                        print("pred_Centroid_L:", pred_l_center)

                    for polygon in gt_mpoly_r:
                        gt_r_center = polygon.centroid
                        gt_Centroid_R[frameNumber] = gt_r_center
                        print("gt_Centroid_R:", gt_r_center)

                    for polygon in pred_mpoly_r:
                        pred_r_center = polygon.centroid
                        pred_Centroid_R[frameNumber] = pred_r_center
                        print("pred_Centroid_R:", pred_r_center)

            ### BREAK ###

            # PLOTTING
            # one video for each trial, need plots of each frame

            # plot on images with contours?
            # temp solution: plot centers on deeplab_labeled_images_test
            # (these images have contours drawn on the images already) --> not work image not right size
                    #self.drawContourImage(pred, gt, imageFName, drawFName, GT=False)

            # function for plotting
            self.plotGrasperCenter(pred_Centroid_L, pred_Centroid_R, gplotRoot)  # save option? choose gt or pred?

            print("proc", os.path.basename(TrialRoot), "count:", frameNum)

    # draw only grasper contours (for suturing task images (with threads, no rings)?)
    def drawContourImage(self, pred, gt, imageFName, drawFName, GT=False):
        [LG_dl, RG_dl] = pred
        [LG_Group_gt, RG_Group_gt] = gt
        image = cv.imread(imageFName)

        # actual/original image
        plt.imshow(image, cmap='gray')

        # for masks
        # img_3 = np.zeros([1612,1612,3],dtype=np.uint8)
        # img_3.fill(255)
        # plt.imshow(img_3, cmap='gray')

        if GT:
            try:
                x, y = unary_union(LG_Group_gt).exterior.xy
                plt.plot(x, y)
                plt.plot(LG_Group_gt.centroid.x, LG_Group_gt.centroid.y)
            except Exception as e:
                print(e, "No LG_Group_gt")

            try:
                x, y = unary_union(RG_Group_gt).exterior.xy
                plt.plot(RG_Group_gt.centroid.x, RG_Group_gt.centroid.y)
                plt.plot(x, y)
            except Exception as e:
                print(e, "no RG GT annotation")

        scale = 1
        linewidth = 1
        try:
            x, y = unary_union(LG_dl).exterior.xy
            x = [xx * scale for xx in x]
            y = [yy * scale for yy in y]
            plt.plot(x, y, color="green", linewidth=linewidth)
        except Exception as e:
            print(e, "No LG DL label")
        try:
            x, y = unary_union(RG_dl).exterior.xy
            x = [xx * scale for xx in x]
            y = [yy * scale for yy in y]
            plt.plot(x, y, color="gold", linewidth=linewidth)
        except Exception as e:
            print(e, "No RG DL label")

        # outPath = os.path.(outputFName,"")

        #plt.axis('off')
        plt.gca().set_axis_off()
        plt.subplots_adjust(top=1, bottom=0, right=1, left=0,
                            hspace=0, wspace=0)
        plt.margins(0, 0)

        #plt.show()
        plt.savefig(drawFName)

        plt.close()

    def plotGrasperCenter(self, left_grasper_coord, right_grasper_coord, gplotRoot):
        # add location of grasper center on original image as markers
        # need center markers at each frame number to make video

        FilenamesInTask = ["Suturing_S02_T01"]  # self.getFilenamesinTask()
        for Trial in FilenamesInTask:
            # DLImagesRoot = os.path.join(self.CWD, self.task, "deeplab_labeled_images", Trial)
            DLImagesRoot = os.path.join(self.deeplabOutputDir, Trial)
            DrawRoot = os.path.join(self.drawContourDir, Trial)
            TrialRoot = os.path.join(self.imagesDir, Trial)
            # TrialRoot = os.path.join(self.plotImagesDir, Trial)
            frameNum = 0
            for root, dirs, files in os.walk(DrawRoot):
                files.sort()
                for file in files:
                    if "frame" not in file:
                        continue
                    frameNum += 1
                    imageRoot = root
                    frameNumber = int(file.replace(".png", "").split("_")[1])
                    trialFname = os.path.basename(root)
                    imageFName = os.path.join(imageRoot, file)

                    #gplotRoot = os.path.join(self.plotImagesDir, trialFname)
                    centerRoot = os.path.join(self.centerImagesDir, trialFname)
                    # plot_file = 'plot_' + file
                    # gplotFName = os.path.join(self.plotImagesDir, trialFname, plot_file)
                    # print("GPLOTFNAME:", gplotFName)

                    # plotImageOutputRoot = os.path.join(self.plotNextToImagesDir, trialFname)
                    # plotImageOutputFName = os.path.join(self.plotNextToImagesDir, trialFname, file)
                    #print("plotImageOutputFName:", plotImageOutputFName)

                    # graph_path = os.path.join(self.CWD, 'grasper_distance_plot.png')
                    # for n in frame number:
                    im = cv.imread(imageFName)  # imageFName raw image? outputFName is labelled imaged
                    print("IMAGEFNAME:", imageFName)

                    # imageFName size: (480, 640, 3); outputFName size: (389, 488, 3)
                    print("IMAGEFNAME SHAPE:", im.shape)

                    # title to the chart
                    plt.title('Location of Grasper Centers')

                    # frame number text
                    f_text = plt.text(540, -10, "Frame " + str(frameNumber))

                    # get coordinates of the grasper centers
                    # dictionary {frame_number : centroid point}
                    # left_grasper_coord[frameNumber] = Point
                    # add center markers
                    try:
                        l_x = left_grasper_coord[frameNumber].x
                        l_y = left_grasper_coord[frameNumber].y

                        l_center_pt, = plt.plot(l_x, l_y, marker='o', color="red")
                    except Exception as e:
                        print(e, "no left grasper center coordinates")

                    try:
                        r_x = right_grasper_coord[frameNumber].x
                        r_y = right_grasper_coord[frameNumber].y

                        r_center_pt, = plt.plot(r_x, r_y, marker='o', color="red")
                    except Exception as e:
                        print(e, "no right grasper center coordinates")

                    # add contours to better understand center markers - done

                    plt.imshow(im)
                    #plt.show()

                    # save image with center markers
                    # change savefig default directory output
                    # to: in task (Suturing), folder grasper_plot_images, in appropriate Trial folder
                    center_filename = 'frame_' + str(frameNumber).zfill(4) + '.png'  # add leading zeros
                    center_file_path = os.path.join(centerRoot, center_filename)
                    # print("CENTER_FILE_PATH: ", center_file_path)

                    # if SAVE == TRUE:
                    #plt.savefig(center_file_path)

                    # removing points
                    try:
                        l_center_pt.remove()
                    except Exception as e:
                        print(e, "no left grasper center to remove")

                    try:
                        r_center_pt.remove()
                    except Exception as e:
                        print(e, "no right grasper center to remove")
                    f_text.remove()
                    # cv.imwrite(plotImageOutputFName, img_plot)


    def plotGrasperDist(self, gt_dist, pred_dist, gplotRoot):
        # plot location of grasper center on 2D plot
        # over time (frame number)
        # plotting distance between vs. time


        # for gt (not implemented)
        # create dataframe
        gt_dataframe = pd.DataFrame({'frame_number': gt_dist.keys(),
                                     'distance': gt_dist.values()})

        # for pred
        # create dataframe
        pred_dataframe = pd.DataFrame({'frame_number': pred_dist.keys(),
                                       'distance': pred_dist.values()})

        # for gt?

        # for pred
        for n in pred_dist.keys():  # for each frame number
            # plot entire graph
            # Plotting the time series of given dataframe
            plt.plot(pred_dataframe.frame_number, pred_dataframe.distance, color='blue')

            # Giving title to the chart using plt.title
            plt.title('Distance Between Graspers by Frames')

            # Providing x and y label to the chart
            plt.xlabel('Frame')
            plt.ylabel('Distance Between Graspers')

            # draw vertical line at each frame number
            # save each graph
            # only one line may be specified; full height
            line = plt.axvline(x=n, color='red', label='axvline - full height')
            # frame number test
            f_text = plt.text(5050, 530, "Frame " + str(n))

            # change savefig default directory output
            # to: in task (Suturing), folder grasper_plot_images, in appropriate Trial folder
            plot_filename = 'plot_frame_' + str(n).zfill(4) + '.png'  # add leading zeros
            plot_file_path = os.path.join(gplotRoot, plot_filename)
            # print("PLOT_FILE_PATH: ", plot_file_path)

            # plt.show()
            # if SAVE == TRUE:
            # plt.savefig(plot_file_path)
            line.remove()
            f_text.remove()

            # by here: should have saved plots for each frame
            # next : call function to add image next to graph


    def plotBesideImage(self):
        FilenamesInTask = ["Suturing_S02_T01"]  # self.getFilenamesinTask()
        for Trial in FilenamesInTask:
            # DLImagesRoot = os.path.join(self.CWD, self.task, "deeplab_labeled_images", Trial)
            TrialRoot = os.path.join(self.imagesDir, Trial)
            # TrialRoot = os.path.join(self.plotImagesDir, Trial)
            frameNum = 0
            for root, dirs, files in os.walk(TrialRoot):
                files.sort()
                for file in files:
                    if "frame" not in file:
                        continue
                    frameNum += 1
                    imageRoot = root
                    frameNumber = int(file.replace(".png", "").split("_")[1])
                    trialFname = os.path.basename(root)
                    imageFName = os.path.join(imageRoot, file)

                    gplotRoot = os.path.join(self.plotImagesDir, trialFname)
                    plot_file = 'plot_' + file
                    gplotFName = os.path.join(self.plotImagesDir, trialFname, plot_file)
                    #print("GPLOTFNAME:", gplotFName)

                    plotImageOutputRoot = os.path.join(self.plotNextToImagesDir, trialFname)
                    plotImageOutputFName = os.path.join(self.plotNextToImagesDir, trialFname, file)
                    print("plotImageOutputFName:", plotImageOutputFName)

                    # graph_path = os.path.join(self.CWD, 'grasper_distance_plot.png')
                    # for n in frame number:
                    im1 = cv.imread(imageFName) # imageFName raw image? outputFName is labelled imaged
                    print("IMAGEFNAME:", imageFName)
                    im2 = cv.imread(gplotFName) # grasper plot
                    print("GPLOTFNAME:", gplotFName)

                    # gplotFName and imageFName size: (480, 640, 3); outputFName size: (389, 488, 3)
                    print(im1.shape)
                    print(im2.shape)

                    # concatenate images of same size: gplotFName and imageFName
                    img_plot = cv.hconcat([im1, im2])
                    # cv.imshow('image and plot', img_plot)
                    # cv.waitKey(0);
                    # if SAVE == TRUE:
                    # cv.imwrite(plotImageOutputFName, img_plot)


    def getContourData(self):
        DeeplabVIARings = {}
        DeeplabVIAPoints = {}
        DeeplabVIAFrames = {}

        for root, dirs, files in os.walk(self.contourDir):
            files.sort()
            for file in files:
                if ".DS_Store" in file:
                    continue
                fileID = file.replace(".json", "")
                # if "frame" not in file:
                label_class = os.path.basename(root)
                if "ring" in label_class:
                    VIAFname = os.path.join(root, file)
                    J = utils.VIARingJSON(VIAFname)
                    if fileID not in DeeplabVIARings.keys():
                        DeeplabVIARings[fileID] = {}
                    # if fileID not in DeeplabVIAFrames.keys():
                    #    DeeplabVIAFrames[file.replace(".json","")] = {}
                    ringNames = ["Ring_4", "Ring_5", "Ring_6", "Ring_7"]
                    R4Dict, R5Dict, R6Dict, R7Dict = J.getRingsPoints()
                    # [R4Frames,R5Frames,R6Frames,R7Frames] = J.getFrameNumbers()
                    DeeplabVIARings[fileID]["Ring_4"] = R4Dict
                    DeeplabVIARings[fileID]["Ring_5"] = R5Dict
                    DeeplabVIARings[fileID]["Ring_6"] = R6Dict
                    DeeplabVIARings[fileID]["Ring_7"] = R7Dict
                    # DeeplabVIARings[file.replace(".json","")][ringClass] = J.getFrameNumbers()
                    print("\t Load data: dl_rings", file, label_class)
                else:
                    VIAFname = os.path.join(root, file)
                    J = utils.VIAPolyJSON(VIAFname)
                    class_name = J.getClassKey(label_class)
                    if fileID not in DeeplabVIAPoints.keys():
                        DeeplabVIAPoints[fileID] = {}
                    if fileID not in DeeplabVIAFrames.keys():
                        DeeplabVIAFrames[fileID] = {}
                    DeeplabVIAPoints[fileID][class_name] = J.getDataDict()
                    DeeplabVIAFrames[fileID][class_name] = J.getFrameNumbers()
                    print("\t Load data: dl_points", file, label_class)
        return DeeplabVIAPoints, DeeplabVIAFrames, DeeplabVIARings

    def getFilenamesinTask(self):
        Dirs = []
        oldRoot = ""
        for root, dirs, files in os.walk(self.imagesDir):
            Dirs = dirs
            oldRoot = root
            break
        return Dirs


    def GetCommonShapes(self, gtPolygons, gtKeypoints, SingleThreadPoints, polylineSeries,
                        LgrasperPoints, RgrasperPoints):
    # def GetCommonShapes(self, gtPolygons, gtKeypoints, SingleThreadPoints, polylineSeries, ThreadContours,
    #                         LgrasperPoints, RgrasperPoints):
        RG_Group_gt = geo.MultiPolygon(
            [geo.Polygon([(poly[i], poly[i + 1]) for i in range(0, len(poly), 2)]) for poly in
             gtPolygons["Right Grasper"]]) if "Right Grasper" in gtPolygons.keys() else []
        LG_Group_gt = geo.MultiPolygon(
            [geo.Polygon([(poly[i], poly[i + 1]) for i in range(0, len(poly), 2)]) for poly in
             gtPolygons["Left Grasper"]]) if "Left Grasper" in gtPolygons.keys() else []

        polys = []
        for i in range(len(polylineSeries)):
            l = len(polylineSeries)
            SingleThreadX = []
            SingleThreadY = []
            points = []
            for j in range(0, len(polylineSeries[i]), 2):
                SingleThreadX.append(polylineSeries[i][j])
                SingleThreadY.append(polylineSeries[i][j + 1])
                points.append((polylineSeries[i][j], polylineSeries[i][j + 1]))
            if (len(points) >= 3):
                currPoly = geo.Polygon(geo.LineString([point for point in points]))
                polys.append(currPoly)

        # SingleThreadPoints = [(SingleThreadX[i],SingleThreadY[i]) for i in range(len(SingleThreadX))]

        # T_Group_gt = geo.MultiPolygon(polys)

        for poly in LgrasperPoints:
            if (len(poly) < 3):
                LgrasperPoints.remove(poly)

        LG_dl = geo.MultiPolygon([geo.Polygon(poly) for poly in LgrasperPoints])
        for poly in RgrasperPoints:
            if (len(poly) < 3):
                RgrasperPoints.remove(poly)
        RG_dl = geo.MultiPolygon([geo.Polygon(poly) for poly in RgrasperPoints])

        # threadPolys = []
        # for k in range(len(ThreadContours)):
        #     if (len(ThreadContours[k]) > 2):
        #         cnt = ThreadContours[k]
        #         threadPolys.append(geo.Polygon([(c[0][0], c[0][1]) for c in cnt]))
        # T_dl = geo.MultiPolygon(threadPolys)

        pred = [LG_dl, RG_dl] #, T_dl]
        gt = [LG_Group_gt, RG_Group_gt] #, T_Group_gt]
        return pred, gt


class VideoInterface:

    def __init__(self, task):
        self.CWD = os.path.dirname(os.path.realpath(__file__))
        self.task = task
        self.imagesDir = os.path.join(self.CWD, task, "images")
        # self.deeplabOutputDir = os.path.join(self.CWD, task, "deeplab_labeled_images")
        # self.OS = "windows"

    def makevideos(self):
        Dirs = ["Suturing_S02_T01"]  # self.getFilenamesinTask()  # These are all the trial we'll generate context labels for. We get this list from the images folder
        print("Trials:", "Suturing_S02_T01")  # FilenamesInTask)
        '''
        Dirs = []
        for root, dirs, files in os.walk(self.imagesDir):
            Dirs = dirs
            break
        print("Trials:", Dirs)
        '''
        TrialNum = 0
        for Trial in Dirs:
            # here: edit directory root of images
            TrialRoot = os.path.join(self.CWD, self.task, "center_images", Trial)
            # plotNextToImagesDir = os.path.join(self.CWD, task, "grasper_plot_sidebyside")
            # centerImagesDir = os.path.join(self.CWD, task, "center_images")

            img_array = []
            for filename in sorted(glob.glob(TrialRoot + '/*.png')):
                img = cv.imread(filename)
                height, width, layers = img.shape
                size = (width, height)
                img_array.append(img)

            # here: edit file name
            out = cv.VideoWriter(self.CWD + '/center_' + Trial + '.mp4', cv.VideoWriter_fourcc(*'mp4v'), 15, size)

            for i in range(len(img_array)):
                for j in range(3):
                    out.write(img_array[i])

            out.release()
            print("Saved Video", Trial)
            TrialNum += 1

        print("Processed ", TrialNum, "trials")


main()