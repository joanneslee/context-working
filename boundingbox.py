import os, sys
import utils
import pathlib
from scipy import ndimage
import cv2 as cv
from shapely import geometry as geo
from shapely.geometry import Polygon

from shapely.ops import unary_union
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.artist import Artist
from matplotlib.offsetbox import AnchoredText

from shapely.ops import polygonize
import math
from matplotlib.patches import Rectangle
import pandas as pd
import glob

def main():
    dir = os.getcwd()
    task = "Suturing"
    # try:
    #     task = sys.argv[1]
    # except:
    #     print("Error: no task provided", "Usage: python deeplab_nokin_context_v3.py <task>", "Default Task" + task)

    I = Iterator(task)

    # get bounding box (around graspers, thread, needle, rings?)
    I.boundingbox(SAVE=False)

    quit();

class Iterator:

    def __init__(self, task):
        self.CWD = os.path.dirname(os.path.realpath(__file__))
        self.task = task
        self.boxImagesDir = os.path.join(self.CWD, task, "bounding_box_images")
        self.centerImagesDir = os.path.join(self.CWD, task, "center_images")
        self.imagesDir = os.path.join(self.CWD, task, "images")
        self.cogitoDir = os.path.join(self.CWD, task, "annotations")
        self.cogitoOutputDir = os.path.join(self.CWD, task, "cogito_labeled_images")
        self.context_output = os.path.join(self.CWD, task, "vis_context_labels_v5")
        self.deeplabOutputDir = os.path.join(self.CWD, task, "deeplab_labeled_images_test")
        self.drawContourDir = os.path.join(self.CWD, task, "draw_contour_images")
        self.ctxConsensusDir = os.path.join(self.CWD, task, "ctx_consensus")
        self.ctxSurgeonDir = os.path.join(self.CWD, task, "ctx_surgeon")
        self.ctxPredDir = os.path.join(self.CWD, task, "ctx_output")
        self.tissueDir = os.path.join(self.CWD, task,
                                      "tissue_keypoints")  # contains VIA labels for the points on the canvas (Suturing)
        self.grasperJawDir = os.path.join(self.CWD, task,
                                          "grasper_jaw_keypoints")  # contains VIA labels for the grasper jaw points
        self.contourDir = os.path.join(self.CWD, task,
                                       "contour_points")  # All of the contour points generated by contours.py

        self.OS = "windows"

    # get closest grasper distance
    def boundingbox(self, SAVE=False):
        # get grasper contour data
        # (from the output of contours.py)
        DeeplabVIAPoints, DeeplabVIAFrames, DeeplabVIARings = self.getContourData()

        # need to generate for all trials and all tasks
        # but for now focus on Suturing_S02_T01
        FilenamesInTask = [
            "Suturing_S02_T01"]  # self.getFilenamesinTask()  # will get all the trials (from the images folder)
        print("Trials:", "Suturing_S02_T01")  # FilenamesInTask)

        for Trial in FilenamesInTask:
            TrialRoot = os.path.join(self.imagesDir, Trial)
            ctxFName = os.path.join(self.ctxConsensusDir, Trial + ".txt")
            ctxPredFName = os.path.join(self.context_output, Trial + ".txt")
            frameNum = 0
            for root, dirs, files in os.walk(TrialRoot):
                files.sort()
                for file in files:
                    if "frame" not in file:
                        continue
                    frameNum += 1
                    imageRoot = root
                    frameNumber = int(file.replace(".png", "").split("_")[1])
                    trialFname = os.path.basename(root)
                    imageFName = os.path.join(imageRoot, file)
                    cogitoRoot = root.replace("images", "annotations")
                    cogitoFName = os.path.join(cogitoRoot, utils.imageToJSON(file))

                    boxRoot = os.path.join(self.boxImagesDir, trialFname)
                    boxFName = os.path.join(self.boxImagesDir, trialFname, file)

                    outputRoot = os.path.join(self.deeplabOutputDir, trialFname)
                    outputFName = os.path.join(self.deeplabOutputDir, trialFname, file)

                    threadRoot = root.replace("images", "deeplab_thread_v3")
                    threadMaskImage = os.path.join(threadRoot, file.replace(".png","_pred.png"))

                    annotationRoot = root.replace("images", "annotations")
                    annotationFile = os.path.join(annotationRoot, utils.imageToJSON(file))

                    # All _dl_points contains the contours that are applicable for this Task and Trial combo
                    All_dl_points = DeeplabVIAPoints[trialFname]  # ["class"]["frame"] = list of points

                    # Getting particular contours (array of points)
                    try:
                        LgrasperPoints = All_dl_points["dl_grasper_L"][str(frameNumber)]
                    except Exception as e:
                        print(e, "in LgrasperPoints")
                        LgrasperPoints = {}

                    try:
                        RgrasperPoints = All_dl_points["dl_grasper_R"][str(frameNumber)]
                    except Exception as e:
                        print(e, "in RgrasperPoints")
                        RgrasperPoints = {}

                    CtxI = utils.ContextInterface2(ctxFName)
                    J = utils.JSONInterface(annotationFile)

                    # gtPolygons are Ground Truth contour points for the cogito labels
                    gtPolygons = J.getPolygonsDict();  # graspers only in KT, (don't need needle mask)
                    # print(type(gtPolygons)) # dict
                    # print(gtPolygons) # tool : points

                    # gtKeypoints are Ground Truth points from cogito labels
                    gtKeypoints = J.getKeyPointsDict();  # not needed, only for GetCommonShapes function
                    cn, polylineSeries = J.getPolyLines();  # not needed
                    SingleThreadX = []
                    SingleThreadY = []
                    for i in range(len(polylineSeries)):
                        l = len(polylineSeries)
                        for j in range(0, len(polylineSeries[i]), 2):
                            SingleThreadX.append(polylineSeries[i][j])
                            SingleThreadY.append(polylineSeries[i][j + 1])
                    SingleThreadPoints = [(SingleThreadX[i], SingleThreadY[i]) for i in range(len(SingleThreadX))]

                    TContours = self.getThreadContours(threadMaskImage)
                    ThreadContours = []
                    minArea = 80
                    for k in range(len(TContours)):
                        cnt = TContours[k]
                        area = cv.contourArea(cnt)
                        if area >= minArea:
                            ThreadContours.append(cnt)

                    #if (not os.path.isdir(outputRoot)):
                    #    path = pathlib.Path(outputRoot)
                    #    path.mkdir(parents=True, exist_ok=True)

                    # pred has all the polygons from Zoey's masks (list of multipolygons)
                    # gt has all the polygons from cogito (list of multipolygons)
                    pred, gt = self.GetCommonShapes(gtPolygons, gtKeypoints, SingleThreadPoints, polylineSeries,
                                                    ThreadContours, LgrasperPoints, RgrasperPoints)

                    # length of pred and gt are both 3 (list of three multipolygons)
                    #print("pred:", pred)
                    #print("pred length:", len(pred))
                    #print("gt length:", len(gt))
                    #print("pred type:", type(pred))

                    # read image
                    im = cv.imread(imageFName)
                    result = im.copy()

                    # bounding box by finding contours
                    '''
                    imgray = cv.cvtColor(im, cv.COLOR_RGB2GRAY, 0)
                    ret, thresh = cv.threshold(imgray, 1, 255, 0)

                    contours, hierarchy = cv.findContours(thresh, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE)
                    print("all:", contours)
                    print("all type:", type(contours))

                    #contours = contours[0] if len(contours) == 2 else contours[1]
                    for cntr in contours:
                        print("CONTOUR:", cntr)
                        x, y, w, h = cv.boundingRect(cntr)
                        cv.rectangle(result, (x, y), (x + w, y + h), (0, 0, 255), 2)
                        print("x,y,w,h:", x, y, w, h)

                    #cv.drawContours(result, contours, -1, (0, 255, 0), 3)
                    '''

                    # bounding box by converting polygon to contour
                    '''
                    # each multipolygons is a different object?
                    # each polygon is the list of points that make up object's contour
                    for multipoly in pred:
                        for poly in multipoly:
                            # convert polygon to numpy array of points
                            poly_arr = np.asarray(poly.exterior.coords)
                            print("poly_arr", poly_arr)
                            print("type poly arr", type(poly_arr))
                            #poly_arr = get_coordinates(poly)
                            #x, y, w, h = cv.boundingRect(poly_arr)
                            #cv.rectangle(result, (x, y), (x + w, y + h), (0, 0, 255), 2)
                            #print("x,y,w,h:", x, y, w, h)
                    '''

                    # bounding box by using polygon points to find bounding box vertices
                    # first: grasper bounding boxes only
                    [LG_dl, RG_dl, T_dl] = pred
                    [LG_Group_gt, RG_Group_gt, T_Group_gt] = gt

                    # left grasper
                    print("LG_dl", LG_dl) # LG_dl is a multipolygon

                    # find lowest and highest x-value
                    for poly in LG_dl:
                        #coord_list = list(poly.exterior.coords)
                        xx, yy = poly.exterior.coords.xy
                        x_min = min(xx)
                        x_max = max(xx)
                        y_min = min(yy)
                        y_max = max(yy)

                        # vertices (start and end vertices only)
                        top_left = (x_min, y_max)
                        print(type(top_left))
                        bottom_right = (x_max, y_min)

                        # Blue color in BGR
                        color = (255, 0, 0)

                        # Line thickness of 2 px
                        thickness = 2

                        result = cv.rectangle(result, (int(top_left[0]), int(top_left[1])), (int(bottom_right[0]), int(bottom_right[1])), color, thickness)

                    # find lowest and highest y-value



                    '''
                    scale = 1
                    linewidth = 1
                    try:
                        x, y = unary_union(LG_dl).exterior.xy
                        x = [xx * scale for xx in x]
                        y = [yy * scale for yy in y]
                        plt.plot(x, y, color="green", linewidth=linewidth)
                    except Exception as e:
                        print(e, "No LG DL label")
                    try:
                        x, y = unary_union(RG_dl).exterior.xy
                        x = [xx * scale for xx in x]
                        y = [yy * scale for yy in y]
                        plt.plot(x, y, color="gold", linewidth=linewidth)
                    except Exception as e:
                        print(e, "No RG DL label")
                    '''

                    # outPath = os.path.(outputFName,"")

                    # plt.axis('off')
                    plt.gca().set_axis_off()
                    plt.subplots_adjust(top=1, bottom=0, right=1, left=0,
                                        hspace=0, wspace=0)
                    plt.margins(0, 0)
                    '''
                    for multipoly in pred:
                        for poly in multipoly:
                            # convert polygon to numpy array of points
                            poly_arr = np.asarray(poly.exterior.coords)
                            print("poly_arr", poly_arr)
                            print("type poly arr", type(poly_arr))
                            # poly_arr = get_coordinates(poly)
                            # x, y, w, h = cv.boundingRect(poly_arr)
                            # cv.rectangle(result, (x, y), (x + w, y + h), (0, 0, 255), 2)
                            # print("x,y,w,h:", x, y, w, h)
                    '''
                    '''
                    for polygon in pred:
                        x, y, w, h = cv.boundingRect(polygon)
                        cv.rectangle(result, (x, y), (x + w, y + h), (0, 0, 255), 2)
                        print("x,y,w,h:", x, y, w, h)
                    '''

                    # save resulting image
                    cv.imwrite(boxFName, result)

                    # show thresh and result
                    cv.imshow("bounding_box", result)
                    cv.waitKey(0)
                    cv.destroyAllWindows()


    # draw only grasper contours (for suturing task images (with threads, no rings)?)
    def drawContourImage(self, pred, gt, imageFName, drawFName, GT=False):
        [LG_dl, RG_dl] = pred
        [LG_Group_gt, RG_Group_gt] = gt
        image = cv.imread(imageFName)

        # actual/original image
        plt.imshow(image, cmap='gray')

        # for masks
        # img_3 = np.zeros([1612,1612,3],dtype=np.uint8)
        # img_3.fill(255)
        # plt.imshow(img_3, cmap='gray')

        if GT:
            try:
                x, y = unary_union(LG_Group_gt).exterior.xy
                plt.plot(x, y)
                plt.plot(LG_Group_gt.centroid.x, LG_Group_gt.centroid.y)
            except Exception as e:
                print(e, "No LG_Group_gt")

            try:
                x, y = unary_union(RG_Group_gt).exterior.xy
                plt.plot(RG_Group_gt.centroid.x, RG_Group_gt.centroid.y)
                plt.plot(x, y)
            except Exception as e:
                print(e, "no RG GT annotation")

        scale = 1
        linewidth = 1
        try:
            x, y = unary_union(LG_dl).exterior.xy
            x = [xx * scale for xx in x]
            y = [yy * scale for yy in y]
            plt.plot(x, y, color="green", linewidth=linewidth)
        except Exception as e:
            print(e, "No LG DL label")
        try:
            x, y = unary_union(RG_dl).exterior.xy
            x = [xx * scale for xx in x]
            y = [yy * scale for yy in y]
            plt.plot(x, y, color="gold", linewidth=linewidth)
        except Exception as e:
            print(e, "No RG DL label")

        # outPath = os.path.(outputFName,"")

        # plt.axis('off')
        plt.gca().set_axis_off()
        plt.subplots_adjust(top=1, bottom=0, right=1, left=0,
                            hspace=0, wspace=0)
        plt.margins(0, 0)

        # plt.show()
        plt.savefig(drawFName)

        plt.close()

    def getContourData(self):
        DeeplabVIARings = {}
        DeeplabVIAPoints = {}
        DeeplabVIAFrames = {}

        for root, dirs, files in os.walk(self.contourDir):
            files.sort()
            for file in files:
                if ".DS_Store" in file:
                    continue
                fileID = file.replace(".json", "")
                # if "frame" not in file:
                label_class = os.path.basename(root)
                if "ring" in label_class:
                    VIAFname = os.path.join(root, file)
                    J = utils.VIARingJSON(VIAFname)
                    if fileID not in DeeplabVIARings.keys():
                        DeeplabVIARings[fileID] = {}
                    # if fileID not in DeeplabVIAFrames.keys():
                    #    DeeplabVIAFrames[file.replace(".json","")] = {}
                    ringNames = ["Ring_4", "Ring_5", "Ring_6", "Ring_7"]
                    R4Dict, R5Dict, R6Dict, R7Dict = J.getRingsPoints()
                    # [R4Frames,R5Frames,R6Frames,R7Frames] = J.getFrameNumbers()
                    DeeplabVIARings[fileID]["Ring_4"] = R4Dict
                    DeeplabVIARings[fileID]["Ring_5"] = R5Dict
                    DeeplabVIARings[fileID]["Ring_6"] = R6Dict
                    DeeplabVIARings[fileID]["Ring_7"] = R7Dict
                    # DeeplabVIARings[file.replace(".json","")][ringClass] = J.getFrameNumbers()
                    print("\t Load data: dl_rings", file, label_class)
                else:
                    VIAFname = os.path.join(root, file)
                    J = utils.VIAPolyJSON(VIAFname)
                    class_name = J.getClassKey(label_class)
                    if fileID not in DeeplabVIAPoints.keys():
                        DeeplabVIAPoints[fileID] = {}
                    if fileID not in DeeplabVIAFrames.keys():
                        DeeplabVIAFrames[fileID] = {}
                    DeeplabVIAPoints[fileID][class_name] = J.getDataDict()
                    DeeplabVIAFrames[fileID][class_name] = J.getFrameNumbers()
                    print("\t Load data: dl_points", file, label_class)
        return DeeplabVIAPoints, DeeplabVIAFrames, DeeplabVIARings

    def getThreadContours(self,threadMaskImage):
        im = cv.imread(threadMaskImage)
        imgray = cv.cvtColor(im,cv.COLOR_RGB2GRAY,0)
        ret, thresh = cv.threshold(imgray, 1, 255, 0)
        ThreadContours, hierarchy = cv.findContours(thresh, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE)
        return ThreadContours

    def GetCommonShapes(self, gtPolygons, gtKeypoints, SingleThreadPoints, polylineSeries, ThreadContours,
                        LgrasperPoints, RgrasperPoints):
        RG_Group_gt = geo.MultiPolygon(
            [geo.Polygon([(poly[i], poly[i + 1]) for i in range(0, len(poly), 2)]) for poly in
             gtPolygons["Right Grasper"]]) if "Right Grasper" in gtPolygons.keys() else []
        LG_Group_gt = geo.MultiPolygon(
            [geo.Polygon([(poly[i], poly[i + 1]) for i in range(0, len(poly), 2)]) for poly in
             gtPolygons["Left Grasper"]]) if "Left Grasper" in gtPolygons.keys() else []

        polys = []
        for i in range(len(polylineSeries)):
            l = len(polylineSeries)
            SingleThreadX = []
            SingleThreadY = []
            points = []
            for j in range(0, len(polylineSeries[i]), 2):
                SingleThreadX.append(polylineSeries[i][j])
                SingleThreadY.append(polylineSeries[i][j + 1])
                points.append((polylineSeries[i][j], polylineSeries[i][j + 1]))
            if (len(points) >= 3):
                currPoly = geo.Polygon(geo.LineString([point for point in points]))
                polys.append(currPoly)

        # SingleThreadPoints = [(SingleThreadX[i],SingleThreadY[i]) for i in range(len(SingleThreadX))]

        T_Group_gt = geo.MultiPolygon(polys)

        for poly in LgrasperPoints:
            if (len(poly) < 3):
                LgrasperPoints.remove(poly)

        LG_dl = geo.MultiPolygon([geo.Polygon(poly) for poly in LgrasperPoints])
        for poly in RgrasperPoints:
            if (len(poly) < 3):
                RgrasperPoints.remove(poly)
        RG_dl = geo.MultiPolygon([geo.Polygon(poly) for poly in RgrasperPoints])

        threadPolys = []
        for k in range(len(ThreadContours)):
            if (len(ThreadContours[k]) > 2):
                cnt = ThreadContours[k]
                threadPolys.append(geo.Polygon([(c[0][0], c[0][1]) for c in cnt]))
        T_dl = geo.MultiPolygon(threadPolys)

        pred = [LG_dl, RG_dl, T_dl]
        gt = [LG_Group_gt, RG_Group_gt, T_Group_gt]
        return pred, gt


main()
